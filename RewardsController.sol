//*~~~> SPDX-License-Identifier: MIT OR Apache-2.0
/*~~~>
    Thank you Phunks, your inspiration and phriendship meant the world to me and helped me through hard times.
      Never stop phighting, never surrender, always stand up for what is right and make the best of all situations towards all people.
      Phunks are phreedom phighters!
        "When the power of love overcomes the love of power the world will know peace." - Jimi Hendrix <3

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((%%%%%
%%%%%((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((%%%%%
%%%%%((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((%%%%%
%%%%%((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((%%%%%
%%%%%((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((%%%%%
%%%%%((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((%%%%%
%%%%%((((((((((((((((((((((((((((((((((((((((@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@(((((((((((((((((((((((((((((((((((%%%%%
%%%%%((((((((((((((((((((((((((((((((((((((((@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@(((((((((((((((((((((((((((((((((((%%%%%
%%%%%(((((((((((((((((((((((((((((((((((@@@@@##############################%%%%%@@@@@((((((((((((((((((((((((((((((%%%%%
%%%%%(((((((((((((((((((((((((((((((((((@@@@@##############################%%%%%@@@@@((((((((((((((((((((((((((((((%%%%%
%%%%%((((((((((((((((((((((((((((((@@@@@########################################%%%%%@@@@@(((((((((((((((((((((((((%%%%%
%%%%%((((((((((((((((((((((((((((((@@@@@########################################%%%%%@@@@@(((((((((((((((((((((((((%%%%%
%%%%%(((((((((((((((((((((((((@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@###############@@@@@(((((((((((((((((((((((((%%%%%
%%%%%(((((((((((((((((((((((((@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@###############@@@@@(((((((((((((((((((((((((%%%%%
%%%%%((((((((((((((((((((@@@@@%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%@@@@@##########@@@@@(((((((((((((((((((((((((%%%%%
%%%%%((((((((((((((((((((@@@@@%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%@@@@@##########@@@@@(((((((((((((((((((((((((%%%%%
%%%%%((((((((((((((((((((@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@(((((((((((((((((((((((((%%%%%
%%%%%((((((((((((((((((((@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@(((((((((((((((((((((((((%%%%%
%%%%%(((((((((((((((SMOKE((((((((((@@@@@/////////////////////////////////////////////@@@@@(((((((((((((((((((((((((%%%%%
%%%%%(((((((((((((((SMOKE((((((((((@@@@@/////////////////////////////////////////////@@@@@(((((((((((((((((((((((((%%%%%
%%%%%(((((((((((((((SMOKE((((((((((@@@@@#PHUNKYJON///////////////#PHUNKYJON//////////@@@@@(((((((((((((((((((((((((%%%%%
%%%%%(((((((((((((((SMOKE((((((((((@@@@@#PHUNKYJON///////////////#PHUNKYJON//////////@@@@@(((((((((((((((((((((((((%%%%%
%%%%%(((((((((((((((SMOKE((((((((((@@@@@/////@EYES////////////////////@EYES///////////////@@@@@((((((((((((((((((((%%%%%
%%%%%(((((((((((((((SMOKE((((((((((@@@@@/////@EYES////////////////////@EYES///////////////EAR@@((((((((((((((((((((%%%%%
%%%%%(((((((((((((((SMOKE((((((((((@@@@@//////////////////////////////////////////////////EAR@@((((((((((((((((((((%%%%%
%%%%%(((((((((((((((SMOKE((((((((((@@@@@//////////////////////////////////////////////////EAR@@((((((((((((((((((((%%%%%
%%%%%(((((((((((((((SMOKE((((((((((@@@@@/////////////////////////////////////////////@@@@@@@@@@((((((((((((((((((((%%%%%
%%%%%(((((((((((((((SMOKE((((((((((@@@@@/////////////////////////////////////////////@@@@@@@@@@((((((((((((((((((((%%%%%
%%%%%(((((((((((((((SMOKE((((((((((@@@@@//////////NOSE@NOSE@////////////////////#####@@@@@(((((((((((((((((((((((((%%%%%
%%%%%(((((((((((((((SMOKE((((((((((@@@@@//////////NOSE@NOSE@////////////////////#####@@@@@(((((((((((((((((((((((((%%%%%
%%%%%((((((((((((((((((((((((((((((@@@@@#####//////////////////////////////##########@@@@@(((((((((((((((((((((((((%%%%%
%%%%%((((((((((((((((((((((((((((((@@@@@#####//////////////////////////////##########@@@@@(((((((((((((((((((((((((%%%%%
%%%%%(((((((((((((((@SPLIFF@SPLIFF@SPLIFF@SPLIFF@@###################################@@@@@(((((((((((((((((((((((((%%%%%
%%%%%(((((((((((((((@SPLIFF@SPLIFF@SPLIFF@SPLIFF@@###################################@@@@@(((((((((((((((((((((((((%%%%%
%%%%%((((((((((EMBER(((((,,,,,,,,,,,,,,,,,,,,,,,,,@@@@@MOUTH&&&&&####################@@@@@(((((((((((((((((((((((((%%%%%
%%%%%((((((((((EMBER(((((,,,,,,,,,,,,,,,,,,,,,,,,,@@@@@MOUTH&&&&&####################@@@@@(((((((((((((((((((((((((%%%%%
%%%%%(((((((((((((((@SPLIFF@SPLIFF@SPLIFF@SPLIFF@@##############################/////@@@@@(((((((((((((((((((((((((%%%%%
%%%%%(((((((((((((((@SPLIFF@SPLIFF@SPLIFF@SPLIFF@@##############################/////@@@@@(((((((((((((((((((((((((%%%%%
%%%%%(((((((((((((((((((((((((((((((((((@@@@@##############################//////////@@@@@(((((((((((((((((((((((((%%%%%
%%%%%(((((((((((((((((((((((((((((((((((@@@@@##############################//////////@@@@@(((((((((((((((((((((((((%%%%%
%%%%%((((((((((((((((((((((((((((((((((((((((@@@@@@@@@@@@@@@@@@@@@@@@@///////////////@@@@@(((((((((((((((((((((((((%%%%%
%%%%%((((((((((((((((((((((((((((((((((((((((@@@@@@@@@@@@@@@@@@@@@@@@@///////////////@@@@@(((((((((((((((((((((((((%%%%%
%%%%%((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((@@@@@///////////////@@@@@(((((((((((((((((((((((((%%%%%
%%%%%((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((@@@@@///////////////@@@@@(((((((((((((((((((((((((%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%@@@@@///////////////@@@@@%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%@@@@@///////////////@@@@@%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

 <~~~*/
pragma solidity  >=0.8.0 <0.9.0;

import "@openzeppelin/contracts/utils/Counters.sol";
import "@openzeppelin/contracts/security/ReentrancyGuard.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/utils/math/SafeMath.sol";
import "@openzeppelin/contracts/token/ERC721/IERC721.sol";
import "@openzeppelin/contracts/token/ERC1155/IERC1155.sol";

interface RoleProvider {
  function hasTheRole(bytes32 role, address _address) external returns(bool);
}
interface Treasury {
  function fetch1155NFTContractsCreated() external returns(uint);
}

contract RewardsControl is ReentrancyGuard {
  using SafeMath for uint;
  using Counters for Counters.Counter;

  /*~~~>
    Roles for designated accessibility
  <~~~*/
  bytes32 public constant PROXY_ROLE = keccak256("PROXY_ROLE"); 

  /*~~~> 
    Accounts receivable for unclaimed fees;
    Goes towards the Developers fund;
  <~~~*/
  uint amountReceivable;
  uint[] tokenAmount;
  address[] tokenAddresses;

  //*~~~> Developers fund!
  address private devSig;

  //*~~~> Split is amount of ETH to split between users;
  uint split;

  //*~~~> upgradable proxy contract addresses
  address public NFTadd;
  address public trsryAdd;
  address public controlAdd;

  /*~~~> Open storage indexes <~~~*/
  uint[] private openStorage;

  //*~~~> counter increments NFTs Trade Offers
  Counters.Counter private _devs;
  Counters.Counter private _users;
  Counters.Counter private _tokens;

  /*~~~> Mapping 
    id to User, 
    id to Tokens,
    user address to id
    token address to id
     <~~~*/
  mapping(uint256 => User) private idToUser; //Internal index
  mapping(uint256 => User) private nftIdToUser; // Tracking NFTs as users to limit claims
  mapping(address => User) private addressToUser;
  mapping(address => uint) private addressToId; //For user Id
  mapping(address => uint) private addressToTokenId; // For token Id
  mapping(uint256 => Token) private idToTokens;
  mapping(uint256 => Dev) private idToDev;
  mapping(address => uint) private addressToDevId;
  /*~~~> sets deployment address as default admin role <~~~*/
  constructor(address _role, address devPhund) {
    roleAdd = _role;
    devSig = devPhund;
  }

  //*~~~> Declaring object structures for User Rewards & Tokens <~~~*/
  struct User {
    bool canClaim;
    uint timestamp;
    uint userId;
    address userAddress;
  }
  struct Dev {
    uint timestamp;
    uint devIndex;
    address devAddress;
  }
  struct Token {
    uint tokenId;
    uint tokenAmount;
    address tokenAddress;
  }

  // Functinon modifier requiring admin accessibility
  address roleAdd;
  modifier hasAdmin(){
    require(RoleProvider(roleAdd).hasTheRole(PROXY_ROLE, msg.sender), "DOES NOT HAVE ADMIN ROLE");
    _;
  }

  // Admin only functions to set proxy addresses
  function setRoleAddress(address _role) public hasAdmin returns(bool){
    roleAdd = _role;
    return true;
  }
  function setDevSigAddress(address _sig) public hasAdmin returns(bool){
    devSig = _sig;
    return true;
  }
  function setTreasuryAddress(address _trsy) public hasAdmin returns(bool){
    trsryAdd = _trsy;
    return true;
  }
  function setControlAdd(address _contAdd) public hasAdmin returns(bool){
    controlAdd = _contAdd;
    return true;
  }

  //*~~~> Declaring event structures
  event NewUser(uint indexed userId, address indexed userAddress);
  event RewardsClaimed(address indexed userAddress);
  event NewDev(address indexed devAddress);
  event RemovedDev(address indexed devAddress);
  event DevClaimed(address indexed devAddress);
  event Received(address, uint);


  /// @notice
  /*~~~>
    for adding dev addresses to claimable array
  <~~~*/
  /// @dev
  /*~~~>
    devAddress: new dev;
  <~~~*/
  /// @return Bool
  function addDev(address devAddress) public nonReentrant returns(bool) {
    require(msg.sender==devSig,"NOT DEV MULTI_SIG");
    uint devLen = _devs.current();
    bool added;
    for (uint i; i<devLen;i++){
      Dev memory _dev = idToDev[i+1];
      if(_dev.devAddress==address(0x0)){
        idToDev[i+1] = Dev(block.timestamp, _dev.devIndex, devAddress);
        addressToDevId[devAddress] = i+1;
        added = true;
      }
    }
    if(!added){
      _devs.increment();
      uint id = _devs.current();
      idToDev[id] = Dev(block.timestamp, id, devAddress);
    }
    emit NewDev(devAddress);
    return true;
  }

  /// @notice
  /*~~~>
    for removing dev addresses from claimable array
  <~~~*/
  /// @dev
  /*~~~>
    devAddress: new dev;
  <~~~*/
  /// @return removed Bool
  function removeDev(address devAddress) public nonReentrant returns(bool) {
    require(msg.sender==devSig,"NOT DEV MULTI_SIG");
    uint id = addressToDevId[devAddress];
    Dev memory _dev = idToDev[id];
    idToDev[id] = Dev(0, _dev.devIndex, address(0x0));
    emit RemovedDev(devAddress);
    return true;
  }

  /// @notice
    /*~~~> 
      Creating new users for rewards
        <~~~*/
   /// @dev
    /*~~~>
     userAddress: user address;
        <~~~*/
    /// @return Bool
  function createUser(address userAddress) public hasAdmin nonReentrant returns(bool) {
    uint userId;
    uint len = openStorage.length;
    if (len>=1){
      userId=openStorage[len-1];
      _remove(len-1);
    } else {
      _users.increment();
      userId = _users.current();
    }
    addressToId[userAddress] = userId;
    idToUser[userId] = User(true, block.timestamp, userId, userAddress);
    emit NewUser(userId, userAddress);
    return true;
  }
  
  /// @notice
  //*~~~> Resetting the user data to revoke claim access after last item sells
  /// @dev
    /*~~~>
     userAddress: user address;
        <~~~*/
  /// @return Bool
  function setUser(bool canTrade, address userAddress) public hasAdmin nonReentrant returns(bool) {
    uint userId = addressToId[userAddress];
    User memory user = idToUser[userId];
    if (canTrade){
      idToUser[userId] = User(true, user.timestamp, user.userId, address(0x0));
    } else {
      openStorage.push(userId);
      addressToId[userAddress] = 0;
      idToUser[userId] = User(false, 0, 0, address(0x0));
    }
    
    return true;
  }

  //*~~~> Claims all eligible rewards for user
  function claimRewards() public nonReentrant {
    uint id = addressToId[msg.sender];
    User memory user = idToUser[id];
    require(user.canClaim==true,"Ineligible!");
    //*~~~> Require 1 day to have passed since last claim
    require(user.timestamp < (block.timestamp - 1 days));
    uint throttle = 1;
    if(user.timestamp > (block.timestamp - 3 days)){
      //*~~~> If the user has claimed in the past 3 days, cut the claim in half
      throttle = 2;
    }
    uint users = fetchUserAmnt();
    uint nfts = Treasury(trsryAdd).fetch1155NFTContractsCreated();
    uint totalUsers = users.add(nfts);
    uint splits = split.div(totalUsers).div(throttle);
    uint[] memory amnt;
    payable(msg.sender).transfer(splits);
    uint len = _tokens.current();
    for (uint i; i < len; i++) {
      Token memory toke = idToTokens[i+1];
      uint ercSplit = (toke.tokenAmount.div(totalUsers)).div(throttle);
      IERC20(toke.tokenAddress).transfer(payable(msg.sender), ercSplit);
      amnt[i+1] = 0;
    }
    user = User(true, block.timestamp, id, user.userAddress);
    emit RewardsClaimed(msg.sender);
  }

  //*~~~> Claims eligible rewards for NFT holders <~~~*//
  function claimNFTRewards(uint nftId) public nonReentrant {
    require(IERC721(NFTadd).balanceOf(msg.sender)>0,"Ineligible!");
    User memory user = nftIdToUser[nftId];
    // Limiting claim abilities to every other day
    require(user.timestamp < (block.timestamp - 1 days));
    uint users = fetchUserAmnt();
    uint nfts = Treasury(trsryAdd).fetch1155NFTContractsCreated();
    uint totalUsers = users.add(nfts);
    uint splits = split.div(totalUsers);
    payable(msg.sender).transfer(splits);
    uint[] memory amnt;
    uint len = _tokens.current();
    for (uint i; i < len; i++) {
      Token memory toke = idToTokens[i+1];
      uint ercSplit = (toke.tokenAmount.div(totalUsers));
      IERC20(toke.tokenAddress).transfer(payable(msg.sender), ercSplit);
      amnt[i+1] = 0;
    }
    user = User(true, block.timestamp, user.userId, msg.sender);
    emit RewardsClaimed(msg.sender);
  }

  /*~~~>
    Allows Dev addresses to withdraw
    Only an address that exists in the dev array will receive anything.
  <~~~*/
  function claimDevRewards() public nonReentrant {
    uint devLen = _devs.current();
    uint devId = addressToDevId[msg.sender];
    Dev memory _dev = idToDev[devId];
    require(_dev.timestamp < (block.timestamp - 1 days));
    if (amountReceivable > 0){
      payable(msg.sender).transfer(amountReceivable.div(devLen));
    }
    if (tokenAmount.length > 0){
      for (uint j; j < tokenAmount.length; j++) {
        if(tokenAmount[j] > 0){
          uint reward = tokenAmount[j+1].div(devLen);
          IERC20(tokenAddresses[j+1]).transfer(payable(msg.sender), reward);
          tokenAmount[j+1]-=reward;
          idToDev[devId] = Dev(block.timestamp, devId, _dev.devAddress);
        }
      }
    }
     emit DevClaimed(msg.sender);
  }

  function splitRewards(uint _split) public payable returns(bool) {
    uint splits = _split.div(4);
    uint userAmnt = splits.mul(3);
    amountReceivable = amountReceivable.add(splits);
    split = split.add(userAmnt);
    return true;
  }

  /// @notice
  /*~~~>
    Splits rewarded ERC20 tokens to all users
  <~~~*/
  /// @dev
  /*~~~>
    amount: how much ERC20 to be deposited
    tokenAddress: contract address of the ERC20
  <~~~*/
  /// @return Bool
  function depositERC20Rewards(uint amount, address tokenAddress) public returns(bool){
    uint id = addressToTokenId[tokenAddress];
    Token memory token = idToTokens[id];
    uint splits = amount.div(4);
    uint userAmnt = splits.mul(3);
    //*~~~> Check to see if the token address exists already
    if(id>0) {
      idToTokens[id] = Token(id, token.tokenAmount+=userAmnt, tokenAddress);
      tokenAmount[id]+=splits;
    } else { //*~~~> If not, create a new ID for it
        _tokens.increment();
        uint tokenId = _tokens.current();
        addressToTokenId[tokenAddress] = tokenId;
        idToTokens[tokenId] = Token(tokenId, userAmnt, tokenAddress);
        tokenAddresses[tokenId] = tokenAddress;
        tokenAmount[tokenId] = splits;
      }
    emit Received(tokenAddress, amount); 
    return true;  
  }

  ///*~~~> For DAO Rewards claims
  Counters.Counter private _ERC20Rewards;
  
  address public accountReceiver;
  uint public accountsReceivable;

  mapping (address => uint) private _indexToRewardsToken;
  mapping (uint256 => ERC20Reward) private _idToERC20;

  //*~~~> ERC20 reward deposits
  struct ERC20Reward {
    uint claimAmount;
    address contractAddress;
  }

  function setAccountRcv(address _recvr) public hasAdmin returns(bool){
    accountReceiver = _recvr;
    return true;
  }

  /// @notice
  /*~~~>
    Function for depositing ERC20 rewards
   <~~~*/
  /// @dev
  /*~~~>
    uint amount: amount of tokens to be deposited; 
    address tokenAddress: token address of the deposit;
  <~~~*/
  /// @return Bool
  function depositDAOERC20Rewards(uint amount, address tokenAddress) public returns(bool){
    bool isIn;
    uint _id = _indexToRewardsToken[tokenAddress];
    //*~~~> Check to see if the token address exists already
    if (_id>0) {
      isIn = true;
      uint tokenId = _id;
      ERC20Reward memory token = _idToERC20[tokenId];
      uint newAmount = token.claimAmount.add(amount);
      token = ERC20Reward(newAmount, tokenAddress);
    } //*~~~> If not, create a new placeholder for it
    if (!isIn) {
      _ERC20Rewards.increment();
      uint tokenId = _ERC20Rewards.current();
      _idToERC20[tokenId] = ERC20Reward(amount, tokenAddress);
      _indexToRewardsToken[tokenAddress] = tokenId;
      }
    emit Received(tokenAddress, amount); 
    return true;  
  }

  /// @notice
  /*~~~>
    Function for depositing ETH
  <~~~*/
  function depositEthToDAO() payable public returns(bool) {
    accountsReceivable = accountsReceivable.add(msg.value);
    return true;
  }

  /// @notice
  /*~~~> 
    Functions for claiming rewards
  <~~~*/
  /// @dev
  /*~~~>
    Withdraws Eth deposited, 
      then checks against the Rewards deposited for withdraw,
      then checks against Redemptions for withdraw;
    Resets claimAmounts back to 0;
    Only accountReceiver address will receive anything;
  <~~~*/
  function withdrawDAORewards() public nonReentrant {
    if (msg.sender == accountReceiver) {
      payable(accountReceiver).transfer(accountsReceivable);
      uint count = _ERC20Rewards.current();
      for (uint i; i < count; i++) {
        ERC20Reward memory token = _idToERC20[i+1];
        if (token.claimAmount > 0) {
          IERC20(token.contractAddress).transfer(msg.sender, token.claimAmount);
          token = ERC20Reward(0, token.contractAddress);
        }
      }
    }
   }

    /// @notice 
  /*~~~> 
    Internal function for removing elements from an array
    Only used for internal storage array index recycling

      In order to reduce storage array size of listed items 
        while maintaining specific enumerable bidId's, 
        any sold or removed item spots are recycled by referring to their index,
        else a new storage spot is created;

        We use the last item in the storage (length of array - 1 for 0 based index position),
        in order to pop off the item and avoid rewriting 
  <~~~*/
  /// @dev
    /*~~~>
      _index: index of the id to be removed;
    <~~~*/
  function _remove(uint _index) internal {
      require(_index < openStorage.length, "index out of bounds");
      openStorage.pop();
    }

  //*~~~> Read functions for fetching amounts and data
  function fetchUsers() public view returns (User[] memory user){
    uint howMany = _users.current();
    for (uint i; i < howMany; i++) {
      if (idToUser[i+1].canClaim) {
        User storage currentUser = idToUser[i+1];
        user[i] = currentUser;
      }
    }
    return user;
  }

  function fetchUserAmnt() public view returns (uint amount) {
    uint count = _users.current();
    for (uint i; i < count; i++) {
      if (idToUser[i+1].canClaim == true) {
        amount++;
      }
    }
    return amount;
  }

  function fetchTokens() public view returns (Token[] memory token){
    uint count = _tokens.current();
    token = new Token[](count);
    for (uint i; i < count; i++) {
      if (idToUser[i+1].canClaim) {
        Token storage currentToken = idToTokens[i+1];
        token[i] = currentToken;
      }
    }
    return token;
  }

  function fetchUserByAddress(address userAdd) public view returns (User memory user){
    user = addressToUser[userAdd]; 
    return user;
  }

  function fetchUserEthRewards(address userAdd) public returns (uint result){
    User memory user = addressToUser[userAdd];
    if(user.canClaim){
      uint throttle=1;
      if(user.timestamp > (block.timestamp - 2 days)){
        throttle = 2;
      }
      uint users = fetchUserAmnt();
      uint nfts = Treasury(trsryAdd).fetch1155NFTContractsCreated();
      uint totalUsers = users.add(nfts);
      uint splits = split.div(totalUsers).div(throttle);
      result = splits;
    }
    return result;
  }

  function fetchUserErcRewards(address userAdd) public returns(address[] memory addresses, uint[] memory result){
    User memory user = addressToUser[userAdd];
    if(user.canClaim){
      uint throttle = 1;
      if(user.timestamp > (block.timestamp - 2 days)){
        throttle = 2;
      }
      uint users = fetchUserAmnt();
      uint nfts = Treasury(trsryAdd).fetch1155NFTContractsCreated();
      uint totalUsers = users.add(nfts);
      for (uint i; i<_tokens.current(); i++) {
        Token memory toke = idToTokens[i+1];
        uint ercSplit = (toke.tokenAmount.div(totalUsers)).div(throttle);
        addresses[i] = toke.tokenAddress;
        result[i] = ercSplit;
      }
    }
    return (addresses, result);
  }

  //*~~~> Fallback functions
  function transferNft(address receiver, address nftContract, uint tokenId) public hasAdmin {
    IERC721(nftContract).safeTransferFrom(address(this), receiver, tokenId);
  }

  function transfer1155(address receiver, address nftContract, uint tokenId, uint amount) public hasAdmin {
    IERC1155(nftContract).safeTransferFrom(address(this), receiver, tokenId, amount, "");
  }

  ///@notice
  /*~~~> External ETH transfer forwarded to controller contract <~~~*/
  event FundsForwarded(uint value, address _from, address _to);
  receive() external payable {
    payable(controlAdd).transfer(msg.value);
      emit FundsForwarded(msg.value, msg.sender, controlAdd);
  }

  function onERC721Received(
      address, 
      address, 
      uint256, 
      bytes calldata
    )external pure returns(bytes4) {
        return bytes4(keccak256("onERC721Received(address,address,uint256,bytes)"));
  }
}