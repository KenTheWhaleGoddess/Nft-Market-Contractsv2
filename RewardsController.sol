//*~~~> SPDX-License-Identifier: MIT OR Apache-2.0
/*~~~>
    Thank you Phunks, your inspiration and phriendship meant the world to me and helped me through hard times.
      Never stop phighting, never surrender, always stand up for what is right and make the best of all situations towards all people.
      Phunks are phreedom phighters!
        "When the power of love overcomes the love of power the world will know peace." - Jimi Hendrix <3

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((%%%%%
%%%%%((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((%%%%%
%%%%%((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((%%%%%
%%%%%((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((%%%%%
%%%%%((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((%%%%%
%%%%%((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((%%%%%
%%%%%((((((((((((((((((((((((((((((((((((((((@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@(((((((((((((((((((((((((((((((((((%%%%%
%%%%%((((((((((((((((((((((((((((((((((((((((@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@(((((((((((((((((((((((((((((((((((%%%%%
%%%%%(((((((((((((((((((((((((((((((((((@@@@@##############################%%%%%@@@@@((((((((((((((((((((((((((((((%%%%%
%%%%%(((((((((((((((((((((((((((((((((((@@@@@##############################%%%%%@@@@@((((((((((((((((((((((((((((((%%%%%
%%%%%((((((((((((((((((((((((((((((@@@@@########################################%%%%%@@@@@(((((((((((((((((((((((((%%%%%
%%%%%((((((((((((((((((((((((((((((@@@@@########################################%%%%%@@@@@(((((((((((((((((((((((((%%%%%
%%%%%(((((((((((((((((((((((((@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@###############@@@@@(((((((((((((((((((((((((%%%%%
%%%%%(((((((((((((((((((((((((@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@###############@@@@@(((((((((((((((((((((((((%%%%%
%%%%%((((((((((((((((((((@@@@@%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%@@@@@##########@@@@@(((((((((((((((((((((((((%%%%%
%%%%%((((((((((((((((((((@@@@@%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%@@@@@##########@@@@@(((((((((((((((((((((((((%%%%%
%%%%%((((((((((((((((((((@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@(((((((((((((((((((((((((%%%%%
%%%%%((((((((((((((((((((@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@(((((((((((((((((((((((((%%%%%
%%%%%(((((((((((((((SMOKE((((((((((@@@@@/////////////////////////////////////////////@@@@@(((((((((((((((((((((((((%%%%%
%%%%%(((((((((((((((SMOKE((((((((((@@@@@/////////////////////////////////////////////@@@@@(((((((((((((((((((((((((%%%%%
%%%%%(((((((((((((((SMOKE((((((((((@@@@@#PHUNKYJON///////////////#PHUNKYJON//////////@@@@@(((((((((((((((((((((((((%%%%%
%%%%%(((((((((((((((SMOKE((((((((((@@@@@#PHUNKYJON///////////////#PHUNKYJON//////////@@@@@(((((((((((((((((((((((((%%%%%
%%%%%(((((((((((((((SMOKE((((((((((@@@@@/////@EYES////////////////////@EYES///////////////@@@@@((((((((((((((((((((%%%%%
%%%%%(((((((((((((((SMOKE((((((((((@@@@@/////@EYES////////////////////@EYES///////////////EAR@@((((((((((((((((((((%%%%%
%%%%%(((((((((((((((SMOKE((((((((((@@@@@//////////////////////////////////////////////////EAR@@((((((((((((((((((((%%%%%
%%%%%(((((((((((((((SMOKE((((((((((@@@@@//////////////////////////////////////////////////EAR@@((((((((((((((((((((%%%%%
%%%%%(((((((((((((((SMOKE((((((((((@@@@@/////////////////////////////////////////////@@@@@@@@@@((((((((((((((((((((%%%%%
%%%%%(((((((((((((((SMOKE((((((((((@@@@@/////////////////////////////////////////////@@@@@@@@@@((((((((((((((((((((%%%%%
%%%%%(((((((((((((((SMOKE((((((((((@@@@@//////////NOSE@NOSE@////////////////////#####@@@@@(((((((((((((((((((((((((%%%%%
%%%%%(((((((((((((((SMOKE((((((((((@@@@@//////////NOSE@NOSE@////////////////////#####@@@@@(((((((((((((((((((((((((%%%%%
%%%%%((((((((((((((((((((((((((((((@@@@@#####//////////////////////////////##########@@@@@(((((((((((((((((((((((((%%%%%
%%%%%((((((((((((((((((((((((((((((@@@@@#####//////////////////////////////##########@@@@@(((((((((((((((((((((((((%%%%%
%%%%%(((((((((((((((@SPLIFF@SPLIFF@SPLIFF@SPLIFF@@###################################@@@@@(((((((((((((((((((((((((%%%%%
%%%%%(((((((((((((((@SPLIFF@SPLIFF@SPLIFF@SPLIFF@@###################################@@@@@(((((((((((((((((((((((((%%%%%
%%%%%((((((((((EMBER(((((,,,,,,,,,,,,,,,,,,,,,,,,,@@@@@MOUTH&&&&&####################@@@@@(((((((((((((((((((((((((%%%%%
%%%%%((((((((((EMBER(((((,,,,,,,,,,,,,,,,,,,,,,,,,@@@@@MOUTH&&&&&####################@@@@@(((((((((((((((((((((((((%%%%%
%%%%%(((((((((((((((@SPLIFF@SPLIFF@SPLIFF@SPLIFF@@##############################/////@@@@@(((((((((((((((((((((((((%%%%%
%%%%%(((((((((((((((@SPLIFF@SPLIFF@SPLIFF@SPLIFF@@##############################/////@@@@@(((((((((((((((((((((((((%%%%%
%%%%%(((((((((((((((((((((((((((((((((((@@@@@##############################//////////@@@@@(((((((((((((((((((((((((%%%%%
%%%%%(((((((((((((((((((((((((((((((((((@@@@@##############################//////////@@@@@(((((((((((((((((((((((((%%%%%
%%%%%((((((((((((((((((((((((((((((((((((((((@@@@@@@@@@@@@@@@@@@@@@@@@///////////////@@@@@(((((((((((((((((((((((((%%%%%
%%%%%((((((((((((((((((((((((((((((((((((((((@@@@@@@@@@@@@@@@@@@@@@@@@///////////////@@@@@(((((((((((((((((((((((((%%%%%
%%%%%((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((@@@@@///////////////@@@@@(((((((((((((((((((((((((%%%%%
%%%%%((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((@@@@@///////////////@@@@@(((((((((((((((((((((((((%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%@@@@@///////////////@@@@@%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%@@@@@///////////////@@@@@%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

 <~~~*/
pragma solidity  >=0.8.0 <0.9.0;

import "@openzeppelin/contracts/utils/Counters.sol";
import "@openzeppelin/contracts/security/ReentrancyGuard.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/utils/math/SafeMath.sol";
import "@openzeppelin/contracts/token/ERC721/IERC721.sol";
import "@openzeppelin/contracts/token/ERC1155/IERC1155.sol";
import "@openzeppelin/contracts/security/Pausable.sol";

interface RoleProvider {
  function hasTheRole(bytes32 role, address _address) external returns(bool);
  function fetchAddress(bytes32 _var) external returns(address);
}
interface MarketMint {
  function fetch1155NFTContractsCreated() external returns(uint);
}

contract RewardsControl is ReentrancyGuard, Pausable {
  using SafeMath for uint;
  using Counters for Counters.Counter;

  /*~~~> 
    amount receivable for dev phund;
  <~~~*/
  uint devEth;
  uint[] tokenAmount;
  address[] tokenAddresses;

  //*~~~> Addresses!
  address roleAdd;

  //*~~~> Split is amount of ETH to split between users;
  uint split;

  //*~~~> upgradable proxy contract addresses
  bytes32 public constant NFTADD = keccak256("NFT");
  address mrktNft = RoleProvider(roleAdd).fetchAddress(NFTADD);

  bytes32 public constant MINT = keccak256("MINT");
  address mintAdd = RoleProvider(roleAdd).fetchAddress(MINT);

  /*~~~> Open storage indexes <~~~*/
  uint[] private openStorage;

  //*~~~> counter increments NFTs Trade Offers
  Counters.Counter private _devs;
  Counters.Counter private _users;
  Counters.Counter private _tokens;

  mapping(uint256 => User) private idToUser; //Internal index => User
  mapping(uint256 => User) private nftIdToUser; // Tracking NFT ids => User, to limit claims
  mapping(address => User) private addressToUser;
  mapping(address => uint) private addressToId; //For user Id
  mapping(address => uint) private addressToTokenId; // For token Id
  mapping(uint256 => Token) private idToTokens;
  mapping(uint256 => DevTeam) private idToDevTeam;
  mapping(address => uint) private addressToDevTeamId;
  mapping(uint => ClaimClock) private idToClock;

  constructor(address _role) {
    roleAdd = _role;
  }

  //*~~~> Declaring object structures for User Rewards & Tokens <~~~*/
  struct User {
    bool canClaim;
    uint claims;
    uint timestamp;
    uint userId;
    address userAddress;
  }
  struct DevTeam {
    uint timestamp;
    uint devIndex;
    address devAddress;
  }
  struct Token {
    uint tokenId;
    uint tokenAmount;
    address tokenAddress;
  }
  struct ClaimClock {
    uint alpha; // initial claim cutoff
    uint delta; // mid claim cutoff
    uint omega; // final claim cutoff
    uint howManyUsers; // total user count set with each distribution call
  }

  /*~~~>
    Roles for designated accessibility
  <~~~*/
  bytes32 public constant PROXY_ROLE = keccak256("PROXY_ROLE"); 
  bytes32 public constant DEV_ROLE = keccak256("DEV_ROLE"); 
  bytes32 public constant CONTRACT_ROLE = keccak256("CONTRACT_ROLE");
  modifier hasAdmin(){
    require(RoleProvider(roleAdd).hasTheRole(PROXY_ROLE, msg.sender), "DOES NOT HAVE ADMIN ROLE");
    _;
  }
  modifier hasDevAdmin(){
    require(RoleProvider(roleAdd).hasTheRole(DEV_ROLE, msg.sender), "DOES NOT HAVE DEV ROLE");
    _;
  }
  modifier hasContractAdmin(){
    require(RoleProvider(roleAdd).hasTheRole(CONTRACT_ROLE, msg.sender), "DOES NOT HAVE CONTRACT ROLE");
    _;
  }

  // Admin only functions to set proxy addresses
  function setRoleAddress(address _role) public hasAdmin returns(bool){
    roleAdd = _role;
    return true;
  }

  function setMintAddress(address _mint) public hasAdmin returns(bool){
    mintAdd = _mint;
    return true;
  }

  //*~~~> Declaring event structures
  event NewUser(uint indexed userId, address indexed userAddress);
  event NewDistribution(uint indexed timestamp, uint userAmount);
  event RewardsClaimed(address indexed userAddress);
  event NewDev(address indexed devAddress);
  event RemovedDev(address indexed devAddress);
  event DevClaimed(address indexed devAddress);
  event SetTime(uint indexed alpha, uint delta, uint omega, uint currentUserCount);
  event Received(address, uint);

  /// @notice
  /*~~~>
    for adding dev addresses to claimable array
  <~~~*/
  /// @dev
  /*~~~>
    devAddress: new dev;
  <~~~*/
  /// @return Bool
  function addDev(address devAddress) public hasDevAdmin nonReentrant returns(bool) {
    uint devLen = _devs.current();
    bool added;
    for (uint i; i<devLen;i++){
      DevTeam memory _dev = idToDevTeam[i+1];
      if(_dev.devAddress==address(0x0)){
        idToDevTeam[i+1] = DevTeam(block.timestamp, _dev.devIndex, devAddress);
        addressToDevTeamId[devAddress] = i+1;
        added = true;
      }
    }
    if(!added){
      _devs.increment();
      uint id = _devs.current();
      idToDevTeam[id] = DevTeam(block.timestamp, id, devAddress);
    }
    emit NewDev(devAddress);
    return true;
  }

  /// @notice
  /*~~~>
    for removing dev addresses from claimable array
  <~~~*/
  /// @dev
  /*~~~>
    devAddress: new dev;
  <~~~*/
  /// @return removed Bool
  function removeDev(address devAddress) public hasDevAdmin nonReentrant returns(bool) {
    uint id = addressToDevTeamId[devAddress];
    DevTeam memory _dev = idToDevTeam[id];
    idToDevTeam[id] = DevTeam(0, _dev.devIndex, address(0x0));
    emit RemovedDev(devAddress);
    return true;
  }

  /// @notice
    /*~~~> 
      Creating new users for rewards
        <~~~*/
   /// @dev
    /*~~~>
     userAddress: user address;
        <~~~*/
    /// @return Bool
  function createUser(address userAddress) public hasContractAdmin nonReentrant returns(bool) {
    uint userId;
    uint len = openStorage.length;
    if (len>=1){
      userId=openStorage[len-1];
      _remove();
    } else {
      _users.increment();
      userId = _users.current();
    }
    addressToId[userAddress] = userId;
    User memory user = User(true, 0, block.timestamp, userId, userAddress);
    idToUser[userId] = user;
    addressToUser[userAddress] = user; 
    emit NewUser(userId, userAddress);
    return true;
  }
  
  /// @notice
  //*~~~> Resetting the user data to revoke claim access after last item sells
  /// @dev
    /*~~~>
     userAddress: user address;
        <~~~*/
  /// @return Bool
  function setUser(bool canTrade, address userAddress) public hasContractAdmin nonReentrant returns(bool) {
    uint userId = addressToId[userAddress];
    User memory user = idToUser[userId];
    if (canTrade){
      idToUser[userId] = User(true, 0, user.timestamp, user.userId, address(0x0));
    } else {
      openStorage.push(userId);
      addressToId[userAddress] = 0;
      idToUser[userId] = User(false, 0, 0, 0,  address(0x0));
    }
    return true;
  }

  /*~~~> Public function anyone can call to split the accumulated user rewards
    When called, the current timestamp is saved as alpha time.
    Old aplha time becomes delta,
      old delta time becomes omega.
    Total user count is saved.
    Can only be called every 2 days.
  <~~~*/
  function setClaimClock() public nonReentrant {
    uint users = fetchUserAmnt();
    uint nfts = MarketMint(mintAdd).fetch1155NFTContractsCreated();
    ClaimClock memory clock = idToClock[8];
    require(clock.alpha < (block.timestamp - 2 days));
    uint alpha = block.timestamp;
    uint delta = clock.alpha;
    uint omega = clock.delta;
    uint totalUsers = users.add(nfts);
    idToClock[8] = ClaimClock(alpha, delta, omega, totalUsers);
    emit SetTime(alpha, delta, omega, totalUsers);
  }

  //*~~~> Claims all eligible rewards for user
  function claimRewards() public nonReentrant {
    uint id = addressToId[msg.sender];
    User memory user = idToUser[id];
    ClaimClock memory clock = idToClock[8];
    require(user.canClaim==true,"Ineligible!");
    /*~~~> Distribute according to timestamp cutoff
      if user.timestamp: 
          > clock.alpha = no claims;
          < clock.alpha > clock.delta && claims == 0 = full claim, else no claim;
          < clock.delta > clock.omega && claims == 1 = 1/2 claim, else no claim;
          < clock.omega && claims == 2 = 1/3 claim, else no claim;
          claims == 3 no claims;
    <~~~*/
    ///*~~~> i.e. alpha: 100, delta: 98, omega:96
      //*~~~> user.timestamp == 99, is less than alpha, greater than omega, 0 claims, gets rewards
    if (user.timestamp < clock.alpha && user.timestamp > clock.delta){
      if (user.claims==0){
        uint userSplits = split.div(clock.howManyUsers);
        payable(msg.sender).transfer(userSplits);
        uint tokenLen = _tokens.current();
        for (uint i; i < tokenLen; i++) {
          Token memory toke = idToTokens[i+1];
          uint ercSplit = (toke.tokenAmount.div(clock.howManyUsers));
          IERC20(toke.tokenAddress).transfer(payable(msg.sender), ercSplit);
          toke.tokenAmount = toke.tokenAmount.sub(ercSplit);
        }
        user.claims+=1;
      }
    }
    ///*~~~> i.e. alpha: 100, delta: 98, omega:96
      //*~~~> user.timestamp == 97, is less than delta, greater than omega, 1 or less claims, gets 1/2 full rewards
    if (user.timestamp < clock.delta && user.timestamp > clock.omega){
      if(user.claims <= 1){
        uint userSplits = split.div(clock.howManyUsers);
        payable(msg.sender).transfer(userSplits.div(2));
        uint tokenLen = _tokens.current();
        for (uint i; i < tokenLen; i++) {
          Token memory toke = idToTokens[i+1];
          uint ercSplit = (toke.tokenAmount.div(clock.howManyUsers)).div(2);
          IERC20(toke.tokenAddress).transfer(payable(msg.sender), ercSplit);
          toke.tokenAmount = toke.tokenAmount.sub(ercSplit);
        }
        user.claims+=1;
      }
    }
    ///*~~~> i.e. alpha: 100, delta: 98, omega:96
      //*~~~> user.timestamp == 95, is less than omega, 2 or less claims, gets 1/3 full reward
    if (user.timestamp < clock.omega && user.claims <= 2){
      uint userSplits = split.div(clock.howManyUsers);
      payable(msg.sender).transfer(userSplits.div(3));
      uint tokenLen = _tokens.current();
      for (uint i; i < tokenLen; i++) {
        Token memory toke = idToTokens[i+1];
        uint ercSplit = (toke.tokenAmount.div(clock.howManyUsers)).div(3);
        IERC20(toke.tokenAddress).transfer(payable(msg.sender), ercSplit);
        toke.tokenAmount = toke.tokenAmount.sub(ercSplit);
      }
      user.claims+=1;
    }
  }

  //*~~~> Claims eligible rewards for NFT holders <~~~*//
  function claimNFTRewards(uint nftId) public nonReentrant {
    require(IERC721(mrktNft).balanceOf(msg.sender)>0,"Ineligible!");
    User memory user = nftIdToUser[nftId];
    // Limiting claim abilities to every other day
    require(user.timestamp < (block.timestamp - 1 days));
    uint users = fetchUserAmnt();
    uint nfts = MarketMint(mintAdd).fetch1155NFTContractsCreated();
    uint totalUsers = users.add(nfts);
    uint splits = split.div(totalUsers);
    payable(msg.sender).transfer(splits);
    uint[] memory amnt;
    uint len = _tokens.current();
    for (uint i; i < len; i++) {
      Token memory toke = idToTokens[i+1];
      uint ercSplit = (toke.tokenAmount.div(totalUsers));
      IERC20(toke.tokenAddress).transfer(payable(msg.sender), ercSplit);
      amnt[i+1] = 0;
    }
    user = User(true, user.claims, block.timestamp, user.userId, msg.sender);
    emit RewardsClaimed(msg.sender);
  }

  /*~~~>
    Allows Dev addresses to withdraw
    Only an address that exists in the dev array will receive anything.
  <~~~*/
  function claimDevRewards() public nonReentrant {
    uint devLen = _devs.current();
    uint devId = addressToDevTeamId[msg.sender];
    DevTeam memory _dev = idToDevTeam[devId];
    require(_dev.timestamp > 0, "Ineligible!");
    require(_dev.timestamp < (block.timestamp - 1 days));
    if (devEth > 0){
      payable(msg.sender).transfer(devEth.div(devLen));
    }
    if (tokenAmount.length > 0){
      for (uint j; j < tokenAmount.length; j++) {
        if(tokenAmount[j] > 0){
          uint reward = tokenAmount[j+1].div(devLen);
          IERC20(tokenAddresses[j+1]).transfer(payable(msg.sender), reward);
          tokenAmount[j+1] = tokenAmount[j+1].sub(reward);
          idToDevTeam[devId] = DevTeam(block.timestamp, devId, _dev.devAddress);
        }
      }
    }
     emit DevClaimed(msg.sender);
  }

  function splitRewards(uint _split) public payable returns(bool) {
    uint splits = _split.div(4);
    uint userAmnt = splits.mul(3);
    devEth = devEth.add(splits);
    split = split.add(userAmnt);
    return true;
  }

  /// @notice
  /*~~~>
    Splits rewarded ERC20 tokens to all users
  <~~~*/
  /// @dev
  /*~~~>
    amount: how much ERC20 to be deposited
    tokenAddress: contract address of the ERC20
  <~~~*/
  /// @return Bool
  function depositERC20Rewards(uint amount, address tokenAddress) public returns(bool){
    uint id = addressToTokenId[tokenAddress];
    Token memory token = idToTokens[id];
    uint splits = amount.div(4);
    uint userAmnt = splits.mul(3);
    //*~~~> Check to see if the token address exists already
    if(id>0) {
      uint newAmnt = token.tokenAmount.add(userAmnt);
      idToTokens[id] = Token(id, newAmnt, tokenAddress);
      tokenAmount[id] = tokenAmount[id].add(splits);
    } else { //*~~~> If not, create a new ID for it
        _tokens.increment();
        uint tokenId = _tokens.current();
        addressToTokenId[tokenAddress] = tokenId;
        idToTokens[tokenId] = Token(tokenId, userAmnt, tokenAddress);
        tokenAddresses[tokenId] = tokenAddress;
        tokenAmount[tokenId] = splits;
      }
    emit Received(tokenAddress, amount); 
    return true;  
  }

  ///*~~~> For DAO Rewards claims
  Counters.Counter private _ERC20Rewards;
  
  address public dao;
  uint public daoEth;

  mapping (address => uint) private _indexToRewardsToken;
  mapping (uint256 => ERC20Reward) private _idToERC20;

  //*~~~> ERC20 reward deposits
  struct ERC20Reward {
    uint claimAmount;
    address contractAddress;
  }

  /// @notice
  /*~~~>
    Function for depositing ERC20 rewards
   <~~~*/
  /// @dev
  /*~~~>
    uint amount: amount of tokens to be deposited; 
    address tokenAddress: token address of the deposit;
  <~~~*/
  /// @return Bool
  function depositDAOERC20Rewards(uint amount, address tokenAddress) public returns(bool){
    bool isIn;
    uint _id = _indexToRewardsToken[tokenAddress];
    //*~~~> Check to see if the token address exists already
    if (_id>0) {
      isIn = true;
      uint tokenId = _id;
      ERC20Reward memory token = _idToERC20[tokenId];
      uint newAmount = token.claimAmount.add(amount);
      token = ERC20Reward(newAmount, tokenAddress);
    } //*~~~> If not, create a new placeholder for it
    if (!isIn) {
      _ERC20Rewards.increment();
      uint tokenId = _ERC20Rewards.current();
      _idToERC20[tokenId] = ERC20Reward(amount, tokenAddress);
      _indexToRewardsToken[tokenAddress] = tokenId;
      }
    emit Received(tokenAddress, amount); 
    return true;  
  }

  /// @notice
  /*~~~>
    Function for depositing ETH
  <~~~*/
  function depositEthToDAO() payable public returns(bool) {
    daoEth = daoEth.add(msg.value);
    return true;
  }

  /// @notice
  /*~~~> 
    Functions for claiming rewards
  <~~~*/
  /// @dev
  /*~~~>
    Withdraws Eth deposited, 
      then checks against the Rewards deposited for withdraw,
      then checks against Redemptions for withdraw;
    Resets claimAmounts back to 0;
    Only accountReceiver address will receive anything;
  <~~~*/
  function withdrawDAORewards() public nonReentrant {
    if (msg.sender == dao) {
      payable(dao).transfer(daoEth);
      uint count = _ERC20Rewards.current();
      for (uint i; i < count; i++) {
        ERC20Reward memory token = _idToERC20[i+1];
        if (token.claimAmount > 0) {
          IERC20(token.contractAddress).transfer(msg.sender, token.claimAmount);
          token = ERC20Reward(0, token.contractAddress);
        }
      }
    }
   }

    /// @notice 
  /*~~~> 
    Internal function for removing elements from an array
    Only used for internal storage array index recycling

      In order to reduce storage array size of listed items 
        while maintaining specific enumerable id's, 
        any sold or removed item spots are recycled by referring to their index,
        else a new storage spot is created;

        We use the last item in the storage (length of array - 1 for 0 based index position),
        in order to pop off the item and avoid rewriting 
  <~~~*/
  function _remove() internal {
      openStorage.pop();
    }

  //*~~~> Read functions for fetching amounts and data
  function fetchUsers() public view returns (User[] memory user){
    uint howMany = _users.current();
    for (uint i; i < howMany; i++) {
      if (idToUser[i+1].canClaim) {
        User storage currentUser = idToUser[i+1];
        user[i] = currentUser;
      }
    }
    return user;
  }

  function fetchUserAmnt() public view returns (uint amount) {
    uint count = _users.current();
    for (uint i; i < count; i++) {
      if (idToUser[i+1].canClaim == true) {
        amount++;
      }
    }
    return amount;
  }

  function fetchTokens() public view returns (Token[] memory token){
    uint count = _tokens.current();
    token = new Token[](count);
    for (uint i; i < count; i++) {
      if (idToUser[i+1].canClaim) {
        Token storage currentToken = idToTokens[i+1];
        token[i] = currentToken;
      }
    }
    return token;
  }

  function fetchUserByAddress(address userAdd) public view returns (User memory user){
    user = addressToUser[userAdd]; 
    return user;
  }

  function fetchClaimTime() public view returns (ClaimClock memory time){
    return idToClock[8];
  }

  //*~~~> Fallback functions
  function transferNft(address receiver, address nftContract, uint tokenId) public hasAdmin {
    IERC721(nftContract).safeTransferFrom(address(this), receiver, tokenId);
  }

  function transfer1155(address receiver, address nftContract, uint tokenId, uint amount) public hasAdmin {
    IERC1155(nftContract).safeTransferFrom(address(this), receiver, tokenId, amount, "");
  }

  ///@notice DEV operations for emergency functions
  function pause() public hasDevAdmin {
      _pause();
  }
  function unpause() public hasDevAdmin {
      _unpause();
  }

  ///@notice
  /*~~~> External ETH transfer forwarded to role provider contract <~~~*/
  event FundsForwarded(uint value, address _from, address _to);
  receive() external payable {
    payable(roleAdd).transfer(msg.value);
      emit FundsForwarded(msg.value, msg.sender, roleAdd);
  }

  function onERC721Received(
      address, 
      address, 
      uint256, 
      bytes calldata
    )external pure returns(bytes4) {
        return bytes4(keccak256("onERC721Received(address,address,uint256,bytes)"));
  }
}
